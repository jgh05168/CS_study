# B-tree

# 사용 이유

- 일반적인 트리 시간 복잡도 O(logN), 트리가 편향된 경우 최악의 시간 복잡도로 O(N)
- B-tree 경우 항상 밸런스를 유지하는 트리 이기 때문에 최악의 경우에도 O(logN)이 보장

# 정의

- 데이터베이스와 파일 시스템에 널리 사용되는 트리 자료 구조의 일종
- 이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조
- B → Balanced를 의미
- 일반적으로 B tree 는 B-tree를 의미하지만 B+tree, B*tree 3가지 존재

![Untitled](/resources/B-tree/b-tree10.png)

# 특징

- 하나의 노드에 많은 수의 정보 가질 수 있음
- 데이터를 key라고 하며 자식 노드를 가리키는 것을 포인터라고 부름

# 규칙

- M차 B-tree라고 할 때 내부 노드(리프 노드를 제외한 노드) M/2개 ~ M개의 자식 노드를 가질 수 있음
- 특정 노드 데이터(key)가 K개라면 자식 노드의 개수(포인터의 개수)는 K+1
- 항상 정렬된 상태로 저장(오름 차순)
- 노드 안에 k개의 데이터가 있다면 자식 노드 수는 k+1개여야 함
- 특정 노드의 왼쪽 서브 트리는 특정 노드의 key보다 작은 값들로, 오른쪽 서브 트리는 큰 값들로 구성
- 노드 내에 데이터는 floor(M/2)-1개 부터 최대 M-1개까지 포함 가능
- 모든 leaf 노드는 같은 레벨에 존재
    
    → 즉 루트 노드에서 모든 리프노드로 가는 경로 길이 같다
    

# KEY 검색

- 루트 노드에서 탐색을 시작 하향식으로 탐색 진행
    - 루트 노드에서 탐색 시작
    - K를 찾았다면 탐색 종료
    - K와 노드의 key값을 비교해 알맞은 자식 노드로
    - 해당 과정을 리프 노드에 도달할 때까지 반복
    - 리프 노드에서도 K 찾지 못한다면 트리에 값 존재 X

# 삽입 과정

- 탐색과 다르게 상향식으로 진행
    - 트리가 비어있다면 root 노드를 할당하고 K를 삽입, root 노드가 가득 찬 경우 노드 분할하여 leaf 노드 생성
    - K가 들어갈 leaf 노드를 검색 과정과 동일하게 탐색
    - 해당 leaf 노드에 자리가 남아 있다면 정렬을 유지하도록 알맞은 위치에 삽입, leaf 노드 꽉 차 있다면 K 삽입 후 해당 노드 분할
    - 노드 분할 되는 경우 노드의 중앙값을 기준으로 분할, 중앙값은 부모 노드로 합쳐지거나 새로운 노드 생성, 중앙값 기준으로 왼쪽 key 왼쪽 자식, 오른쪽 key는 오른쪽 자식으로 생성
- ex) 13을 key에 삽입 하는 경우
    
    ![Untitled](/resources/B-tree/b-tree1.png)
    
    ![Untitled](/resources/B-tree/b-tree2.png)
    
    ![Untitled](/resources/B-tree/b-tree3.png)
    
    ![Untitled](/resources/B-tree/b-tree4.png)
    

# 데이터 삭제

- 규칙에 위반될 경우 조건에 맞도록 트리 재구조화

### 임의 용어 정의

Lmax = 현재 노드의 왼쪽 자손 중 가장 큰 key

Rmin = 현재 노드의 오른쪽 자손 중 가장 작은 key

par = 현재 노드를 가리키는 부모 노드의 포인터의 오른쪽 끝에 있는 key 가장 우측에 있는  포인터인 경우 왼쪽에 있는 key 

## 삭제하는 경우

1. 삭제할 key가 leaf 노드에 있는 경우
    - 현재 노드의 key 수가 최소보다 큰 경우
        - 단순 삭제 가능
    - 현재 노드의 key 수가 최소이고, 왼쪽 또는 오른쪽 형제 노드의 key 수가 최소보다 큰 경우
        - K를 par로 바꿔 준다 그리고 par를 왼쪽 형제 노드의 key 수가 최소보다 크다면 Lmax로, 오른쪽 형제 노드의 key 수가 최소보다 크다면 Rmin으로 바꿔 준다
        
        ![Untitled](/resources/B-tree/b-tree5.png)
        
    - 현재 노드와 왼쪽, 오른쪽 형제 노드의 key 수가 최소, 부모 노드의 key 수가 최소보다 큰 경우
        - K를 삭제하고 par를 부모 노드에서 분할하여 형제 노드와 합쳐준다
        
        → 부모 key 하나 줄고 자식 노드 수도 하나 줄어든다
        
        ![Untitled](/resources/B-tree/b-tree6.png)
        
    - 현재 노드와 왼쪽 오른쪽 형제 노드, 부모 노드 모두 key 수가 최소인 경우
        - 부모 노드가 root인 subtree의 높이가 줄어들기 때문에 트리 재구조화 필요
        - 2번째 경우의 현재 노드와 자식 노드 key 수가 최소인 경우와 동일
2. 삭제할 key가 leaf 노드 제외한 노드에 있는 경우
    - 현재 노드 또는 자식 노드의 key 수가 최소보다 큰 경우
        - K의 Lmax 또는 Rmin과 자리를 바꿔 준다
        - 이후 과정은 1번째 경우와 동일
        
        ![Untitled](/resources/B-tree/b-tree7.png)
        
    - 현재 노드와 자식 노드 key 수가 최소인 경우
        1. K를 삭제하고 K의 양쪽 자식을 하나로 합친다. 합쳐진 노드를 n1이라고 했을 때
        2. K의 par를 K의 형제 노드에 합쳐준다 합쳐진 노드를 n2라 하고
        3. n1을 n2의 자식이 되도록 연결
        4. 만약 n2의 key 수가 최대보다 크다면 key 삽입 과정과 동일하게 분할 
        5. 만약 n2의 key 수가 최소보다 작다면 2로 돌아가 동일한 과정 반복
        
        ![Untitled](/resources/B-tree/b-tree8.png)
        
        ![Untitled](/resources/B-tree/b-tree9.png)
