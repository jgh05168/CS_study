# 명령어

## 3-1 소스 코드와 명령어

- 고급 언어 : 사람을 위한 언어
- 저급 언어 : 컴퓨터가 직접 이해하고 실행할 수 잇는 언어

> 따라서 고급언어로 작성된 소스코드가 실해되려면 저급언어로 변환되어야 한다

### 저급언어
- 기계어 : 0과 1의 명령어 비트로 이루어진 언어

- 어셈블리어 : 기계어를 읽기 편한 형태로 변역한 언어

### 컴파일 언어와 인터프리터 언어
- 컴파일? 인터프리터?
> 고급언어를 저급언어로 변환하는 방식

#### 컴파일 언어
> 컴파일러에 의해 소스코드 전체가 저급언어로 변환되어 실행되는 고급언어 ex) C

- 만약 소스 코드 내에서 오류 발견시 컴파일 실패

- 목적코드 : 컴파일러를 통해 저급 언어로 변환된 코드

#### 인터프리터 언어
> 인터프리터에 의해 소스코드가 한 줄 씩 실행되는 고급언어 ex) Python

- 한 줄씩 저급언어로 변환하여 한줄 씩 실행

- 컴파일 언어와 달리 소스코드에 문제가 있어도 발생 전까지는 실행된다

> 컴퓨터가 이해 할 수 있는 언어인 목적코드를 얻어내 한번에 돌리는 컴파일 언어보다


>목적 파일 vs 실행 파일
>• 목적 파일과 실행 파일은 둘 다 기계어로 이루어진 파일
>• But, 목적 파일과 실행 파일은 다르다
>• 목적 파일은 링킹(linking)을 거친 이후에야 실행 파일이 된다

## 3-2 명령어의 구조
### 연산코드와 오퍼랜드
```t
명령어 
= '명령내용' + '대상' 
= '연산코드' + '오퍼랜드'
= push rbp # 어셈블리어도 '연산코드 + 오퍼랜드' 형태
```

#### 오퍼랜드
> 연산에 사용할 데이터 or 연산에 사용할 데이터가 저장된 위치
> '주소필드'라고도 함

오퍼랜드의 개수에 따라서 0-주소 명령어, 1-주소-명령어 ... 라고 함

#### 연산코드
> 명령어가 수행할 연산

<details>
<summary>데이터 전송</summary>
<div markdown="1">

- MOVE: 데이터를 옮겨라
- STORE: 메모리에 저장하라
- LOAD (FETCH): 메모리에서 CPU로 데이터를 가져와라
- PUSH: 스택에 데이터를 저장하라
- POP: 스택의 최상단 데이터를 가져와라

</div>
</details>

<details>
<summary>산술/논리 연산</summary>
<div markdown="1">

- ADD / SUBTRACT / MULTIPLY / DIVIDE: 덧셈 / 필셈 / 곱셈 / 나눗셈을 수쾸하라
- INCREMENT / DECREMENT: 오퍼랜드에 1올 더하라 / 오퍼랜드에 1 을 빼라
- AND / OR / NOT: AND / OR / NOT 연산을 수행하라
- COMPARE: 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라

</div>
</details>

<details>
<summary>제어 흐름 변경</summary>
<div markdown="1">

- JUMP: 특정 주소로 실행 순서를 옮겨라
- CONDITIONALJUMP: 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
- HALT: 프로그램의 실행을 멈춰라
- CALL: 되돌아올 주소를 저장한 재 특정 주소로 실행 순서를 옮겨라
- RETURN: CALL을 호출할 때 저장했던 주소로 돌아가라

</div>
</details>

<details>
<summary>입출력 제어</summary>
<div markdown="1">

- READ(INPUT): 특정 입출력 장지로부터 데이터를 읽어라
- WRITE(OUTPUT): 특정 입출력 장지로 데이터를 써라
- START IO: 입출력 장치를 시작하라
- TEST IO: 입출력 장지의 상태를 확인하라

</div>
</details>


### 주소 지정 방식
>**오퍼랜드 필드에 데이터가 저장된 위치를 명시 할 때 사용할 데이터 위치를 찾는 방법**

- 왜 오퍼랜드 필드에 메모리나 레지스터의 주소를 담을까?

> 명령어의 길이 때문
![주소지정이유](/resources/Computer%20Science/Computer%20Architecture/opland.png)
- 명령어의 크기가 제한되어 있기 때문에 오퍼랜드에 담을 수 있는 정보는 한정적이다. 여기에 오퍼랜드 개수가 늘어나면 연산코드를 제외한 남은 공간은 나누어 갖기 때문에 정보가 더 작아진다.

> 여기서 메모리 주소를 명시한다면 표현 가능한 정보 가짓수는 메모리의 크기만큼 커지고
> 레지스터 이름을 명시하면 해당 레지스터가 저장할 수 있는 공간 만큼 커진다

- 유효주소 : 연산 대상의 데이터가 저장된 위치

#### 즉시 주소 지정방식
> 연산에 사용할 데이터 오퍼랜드 필드에 직접 명시<br>
> 단점 : 연산데이터 크기 작음<br>
> 장점 : 찾는 과정 없어 빠름

#### 직접 주소 지정방식
> 오퍼랜드 필드에 유효주소를 직접적으로 명시하는 방식

- 표현할 수 있는 데이터 크기는 커졌지만
- 유효 주소를 표현에 제한이 생길 수 있음

#### 간접 주소 지정방식
> 유효 주소의 주소를 오퍼랜드 필드에 명시

- 단점 : 두 번의 메모리 접근으로 느림


#### 레지스터 주소 지정 방식
> 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드에 직접 명시

- 일반적으로 CPU 외부에 있는 메모리 보다 CPU 내부에 있는 레지스터에 접근하는게 더 빠름

- 표현 데이터에 한계

#### 레지스터 간접 주소 지정 방식
> 연산에 사용할 데이터를 메모리에 저장하고, 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시

- 간접 주소 지정방식 과정에서 중간 과정이 메모리가 아닌 레지스터를 거쳐서 더 빠름




## C 언어의 컴파일 과정

![C언어 컴파일 과정](/resources/Computer%20Science/Computer%20Architecture/C_compile.png)

### 전처리 과정 (preprocesssing)
- 본격적으로 컴파일하기 전에 처리할 작업들
- 외부에 선언된 다양한 소스 코드, 라이브러리 포함 (e.g. #include)
- 프로그래밍의 편의를 위해 작성된 매크로 변환 (e.g. #define)
- 컴파일할 영역 명시 (e.g. #if, #ifdef, •••)

### 파일 과정 (compiling)
- 전처리가 완료 되어도 여전히 소스 코드
- 전처리 완료된 소스 코드를 저급 언어(`어셈블리 언어)로 변한

### 어셈블 과정 (assembling)
- 어셈블리어를 기계어로 변환
- 목적 코드(object file)를 포함하는 목적 파일이 됨
